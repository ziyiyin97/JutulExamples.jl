using Jutul
using JutulDarcy
using LinearAlgebra
using PyPlot
## Example demonstrating optimzation of parameters against observations
# We create a simple test problem: A 1D nonlinear displacement. The observations
# are generated by solving the same problem with the true parameters. We then
# match the parameters against the observations using a different starting guess
# for the parameters, but otherwise the same physical description of the system.

function setup_bl(;nc = 100, time = 1.0, nstep = 100, poro = 0.1, perm = 9.8692e-14)
    T = time
    tstep = repeat([T/nstep], nstep)
    G = get_1d_reservoir(nc, poro = poro, perm = perm)
    nc = number_of_cells(G)

    bar = 1e5
    p0 = 1000*bar
    # Define system and realize on grid
    sys = ImmiscibleSystem((LiquidPhase(), VaporPhase()))
    model = SimulationModel(G, sys)
    kr = BrooksCoreyRelPerm(sys, [2.0, 2.0])
    replace_variables!(model, RelativePermeabilities = kr)
    tot_time = sum(tstep)
    irate = 5*1000*sum(G.grid.pore_volumes.*poro)/tot_time
    src  = [SourceTerm(1, irate, fractional_flow = [1.0-1e-3, 1e-3]), 
            SourceTerm(nc, -irate, fractional_flow = [0.0, 1.0])]
    forces = setup_forces(model, sources = src)

    parameters = setup_parameters(model, PhaseViscosities = [1e-4, 1e-3], density = [700.0, 1000.0]) # 0.1 and 1 cP
    state0 = setup_state(model, Pressure = p0, Saturations = [0.0, 1.0])

    return (model, state0, parameters, forces, tstep)
end
# Number of cells and time-steps
N = 100
Nt = 100
poro_ref = 0.1
perm_ref = 9.8692e-14
# Set up and simulate reference
model_ref, state0_ref, parameters_ref, forces, tstep = setup_bl(nc = N, nstep = Nt, poro = poro_ref, perm = perm_ref)
states_ref, _ = simulate(state0_ref, model_ref, tstep, parameters = parameters_ref, forces = forces, info_level = 1, max_timestep_cuts = 1000)
# Set up another case where the porosity is different
model, state0, parameters, = setup_bl(nc = N, nstep = Nt, poro = 2*poro_ref, perm = 1.0*perm_ref)
states, rep = simulate(state0, model, tstep, parameters = parameters, forces = forces, info_level = 1, max_timestep_cuts = 1000)
# Plot the results
fig = figure();
subplot(1,2,1)
title("Saturation")
plot(states_ref[end][:Saturations][1, :], label = "Reference")
plot(states[end][:Saturations][1, :], label = "Initial guess")
legend()
subplot(1,2,2)
title("Pressure")
plot(states_ref[end][:Pressure], label = "Reference")
plot(states[end][:Pressure], label = "Initial guess")
legend()
savefig("init-s-p.png", bbox_inches="tight", dpi=300)

# Define objective as mismatch between water saturation in current state and
# reference state. The objective function is currently a sum over all time
# steps. We implement a function for one term of this sum.
function mass_mismatch(m, state, dt, step_no, forces)
    state_ref = states_ref[step_no]
    fld = :Saturations
    val = state[fld]
    ref = state_ref[fld]
    err = 0
    for i in axes(val, 2)
        err += (val[1, i] - ref[1, i])^2
    end
    return dt*err
end
@assert Jutul.evaluate_objective(mass_mismatch, model, states_ref, tstep, forces) == 0.0
@assert Jutul.evaluate_objective(mass_mismatch, model, states, tstep, forces) > 0.0

## Set up a configuration for the optimization. This by default enables all parameters for
# optimization, with relative box limits 0.1 and 10 specified here. If
# use_scaling is enabled the variables in the optimization are scaled so that
# their actual limits are approximately box limits.
cfg = optimization_config(model, parameters, use_scaling = true, rel_min = 0.1, rel_max = 10)
for (ki, vi) in cfg
    if ki in [:TwoPointGravityDifference,
              :PhaseViscosities]
        # We are not interested in matching gravity effects or viscosity here.
        vi[:active] = false
    end
    if ki == :Transmissibilities
        # Transmissibilities are derived from permeability and varies significantly. We can set
        # log scaling to get a better conditioned optimization system, without changing the limits
        # or the result.
        vi[:scaler] = :log
    end
end
print_obj = 100
# Set up parameter optimization. This gives us a set of function handles together with initial guess and limits.
# Generally calling either of the functions will mutate the data Dict. The options are:
# F_o(x) -> evaluate objective
# dF_o(dFdx, x) -> evaluate gradient of objective, mutating dFdx (may trigger evaluation of F_o)
# F_and_dF(F, dFdx, x) -> evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.
F_o, dF_o, F_and_dF, x0, lims, data = setup_parameter_optimization(model, state0, parameters, tstep, forces, mass_mismatch, cfg, print = print_obj, param_obj = true);
F_initial = F_o(x0)
dF_initial = dF_o(similar(x0), x0)

mean(x) = sum(x)/length(x)

using Printf, Test
function grad_test(misfit, x0, dx, g; maxiter=6, h0=5f-2, data=false, stol=1f-1)
    # init
    err1 = zeros(Float32, maxiter)
    err2 = zeros(Float32, maxiter)
    
    gdx = data ? g : dot(g, dx)
    f0 = misfit(x0)
    h = h0

    @printf("%11.5s, %11.5s, %11.5s, %11.5s, %11.5s, %11.5s \n", "h", "gdx", "e1", "e2", "rate1", "rate2")
    for j=1:maxiter
        f = misfit(x0 + h*dx)
        err1[j] = norm(f - f0, 1)
        err2[j] = norm(f - f0 - h*gdx, 1)
        j == 1 ? prev = 1 : prev = j - 1
        @printf("%5.5e, %5.5e, %5.5e, %5.5e, %5.5e, %5.5e \n", h, h*norm(gdx, 1), err1[j], err2[j], err1[prev]/err1[j], err2[prev]/err2[j])
        h = h * .8f0
    end

    rate1 = err1[1:end-1]./err1[2:end]
    rate2 = err2[1:end-1]./err2[2:end]
    @test isapprox(mean(rate1), 1.25f0; atol=stol)
    @test isapprox(mean(rate2), 1.5625f0; atol=stol)
end

dx0 = rand(length(x0))
dx0 = dx0/norm(dx0) * norm(x0)/10
grad_test(F_o, x0, dx0, dF_initial)
